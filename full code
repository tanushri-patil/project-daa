!pip install networkx matplotlib ipywidgets

import networkx as nx
import matplotlib.pyplot as plt
import random
import ipywidgets as widgets
from IPython.display import display, clear_output

# -------------------------------------------------------
# üèô  Minimum Spanning Tree (Kruskal‚Äôs Algorithm) - Mumbai Network
# -------------------------------------------------------

# Step 1: Mumbai places (nodes)
places = [
    "Hospital", "School", "Mall", "Police Station", "Railway Station",
    "Bus Stop", "Temple", "Restaurant", "Garden", "Fire Station"
]

place_categories = {
    "Hospital": "Emergency",
    "Fire Station": "Emergency",
    "Police Station": "Emergency",
    "School": "Education",
    "Mall": "Leisure",
    "Restaurant": "Leisure",
    "Garden": "Leisure",
    "Temple": "Religious",
    "Railway Station": "Transport",
    "Bus Stop": "Transport"
}

category_colors = {
    "Emergency": "red",
    "Education": "orange",
    "Leisure": "green",
    "Religious": "purple",
    "Transport": "blue"
}

# Step 2: Randomly generate routes between places
edges = []
for i in range(len(places)):
    for j in range(i + 1, len(places)):
        if random.random() < 0.3:
            edges.append((places[i], places[j], random.randint(1, 15)))

# Step 3: Union-Find structure
class UnionFind:
    def __init__(self, nodes):
        self.parent = {node: node for node in nodes}

    def find(self, node):
        if self.parent[node] != node:
            self.parent[node] = self.find(self.parent[node])
        return self.parent[node]

    def union(self, a, b):
        root_a, root_b = self.find(a), self.find(b)
        if root_a != root_b:
            self.parent[root_b] = root_a
            return True
        return False

# Step 4: Kruskal‚Äôs Algorithm
def kruskal_mst(edges, nodes):
    edges = sorted(edges, key=lambda x: x[2])
    uf = UnionFind(nodes)
    mst = []
    total_cost = 0

    for u, v, w in edges:
        if uf.union(u, v):
            mst.append((u, v, w))
            total_cost += w
    return mst, total_cost

# Step 5: Draw MST
def draw_mst(mst, total_cost, path=None):
    G = nx.Graph()
    G.add_weighted_edges_from(mst)
    pos = nx.spring_layout(G)

    node_colors = [category_colors[place_categories[node]] for node in G.nodes()]
    nx.draw(G, pos, with_labels=True, node_color=node_colors, node_size=1100, font_weight='bold')
    nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): w for u, v, w in mst})

    if path:
        nx.draw_networkx_edges(G, pos, edgelist=list(zip(path, path[1:])), edge_color='red', width=3)

    plt.title(f"Mumbai Network (Total Distance: {total_cost} km)")
    plt.show()
    return G

# Step 6: Path between two places
def find_path(G, start, end):
    try:
        return nx.shortest_path(G, source=start, target=end, weight='weight')
    except nx.NetworkXNoPath:
        return None

# Step 7: Run Kruskal and show result
mst, total_cost = kruskal_mst(edges, places)
G = draw_mst(mst, total_cost)

# Step 8‚Äì9: Interactive UI with widgets
start_dropdown = widgets.Dropdown(options=places, description="Start:")
end_dropdown = widgets.Dropdown(options=places, description="End:")
button = widgets.Button(description="Find Route")
output = widgets.Output()

def on_button_click(b):
    with output:
        clear_output()
        start = start_dropdown.value
        end = end_dropdown.value
        if start == end:
            print(" Start and destination must be different.")
            return
        path = find_path(G, start, end)
        if path:
            path_cost = sum(G[path[i]][path[i + 1]]['weight'] for i in range(len(path) - 1))
            print(f"Shortest Path from {start} to {end}: {' ‚Üí '.join(path)}")
            print(f" Minimum Cost of this Route: {path_cost} km")
            print(f"Total Minimum Cost of Entire Network: {total_cost} km")
            draw_mst(mst, total_cost, path)
        else:
            print(f" No path found between {start} and {end} in the MST.")

button.on_click(on_button_click)

display(widgets.HTML("<h3>üö¶ Choose Your Route</h3>"))
display(start_dropdown, end_dropdown, button, output)

# Step 10: Time Complexity
print("\n Time Complexity of Kruskal‚Äôs Algorithm:")
print(" Sorting edges: O(E log E)")
print(" Union-Find operations: O(E log V)")
print(" Overall Time Complexity: O(E log E)")


print("\n Time Complexity of Kruskal‚Äôs Algorithm:")
print(" Sorting edges: O(E log E)")
print(" Union-Find operations: O(E log V)")
print(" Overall Time Complexity: O(E log E)")rall Time Complexity: O(E log E)")
